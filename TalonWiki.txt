====== Talon ======

---- dataentry extension ----
author_mail   : maligan@rambler.ru Alexandr Frolov
description   : UI Engine  # enter a short description of the extension
compatible    :            # the Starling version you tested the extension with
tags          :            # enter a few tags, separated by commas
homepage_url  : https://github.com/Maligan/Starling-Extension-Talon
----

===== Teaser =====
<flash left 758x256 https://dl.dropboxusercontent.com/u/31235920/TalonTeaser/TalonTeaser.swf>
wmode direct
</flash>

===== Overview =====
Starling's Talon - это легковесный и простой UI Layout движок и язык-подмножество XML. Позволяет создавать гибкие/адаптивные интерфейсы под любые размеры и разрешения экрана. Позволяет быстро прототипировать даже сложные макеты интерфейсов.

<note warning>
 Важно: Talon не  является набором виджетов/котролов (like feathers) и не содержит ни одного в своём наборе.
</note>
==== Power of XML & CSS ====
<code xml>
<node id="dialog">
	<label text="Hello World" />
	<node>
		<button />
		<button />
	</node>
</node>
</code>

<code css>
#dialog
{
	backgroundImage: resource('dialog-background');
	fontName: Verdana;
	fontColor: white;
	fontSize: 16px;
}
</code>
==== Flexible Layouts ====
Макеты позволяют создавать гибкие и адаптивные интерфейсы для игр, движок берёт на себя нужные вычисления позиций размеров элементов под любые размеры экранов и разрешения.
=== Absolute ===
Бессвязные элементы
<note tip>
For create center aligned container within parent wich has absolute layout.
<code xml>
<node position="50%" pivot="50%" />
</code>
</note>
=== Flow ===
Свзяь между ээлементами по 1 оси
=== Grid ===
На текущий момент не реализовано
==== WYSIWYG Designer ====
Вместе с библиотекой предоставляется утилитная программа - просмотрщик UI элементов созданных при помощи Talon.

===== Getting Started with Talon =====

===== Under the Hood =====
==== Node ====
Узел базовый элемент в движке

<code as3>
var node:Node = new Node();

// Generic attribute accsess
node.setAttribute("width", "10px");
trace(node.getAttribute("width"));  // 10px
trace(node.width.amount);           // 10
trace(node.width.unit);             // px

// Strong typed width attrubute accsess
node.width.setTo(5, Gauge.PERCENT)
trace(node.getAttribute("width"));  // 5%
trace(node.width.amount);           // 5
trace(node.width.unit);             // %
</code>

=== Styles ===
=== Resources ===
==== Layout ====
Layout - тот механизм который раставляющий элементы интерфейса по экрану динамически.
Под расставлянием подразумеваестя определение прямоугольника который должен быть занят элементом полностью.
Каждый узел обладает своей техникой расставляения дочерних объектов.

<note important>
Размеры и положение узла определяется **только родительским узлом**, без исключений. Родительский узел может //использовать// либо //игнорировать// любой аттрибут потомка для его ранжирования.
</note>
=== Gauge ===
Прежде чем перейти к системе макетов, нужно разобратся с таким базовым классом как Gauge.
Gauge - это именнованное значение выраженное в каких-либо единицах измерений. Доступны следующие единицы измерения:

  * **Pixel** (designated as //px//) - обычный пиксел (regular pixel)
  * **Point** (designated as //pt//) - определяется при помощи CSF и различается на ретина/не ретина устройствах, в обычных условиях 1pt = 1px, на ретине 1pt = 2px
  * **Millimeter** (designated as //mm//) - обычный миллиметр эта ядиница является устройство независомой. И например на экране телефона 10mm может занимать 25% экрана, а на экране компьютера может быть и 5% (тут дать картинку)
  * **Ems** (designated as //em//) - данная единица измерения взаимствована из html, и 1em = fontSize в текущем узле.
  * **Percent** (designated as //%//) - указывает пропорциональныя размер относительно целевого значения. Целевое значение зависит от свойства к которому применяется размер, например, для ''width'' проценты задаются относительно значения ''width'' родительского узла.
  * **Star** (designated as //*//) - некоте подобие процентов, с той лишь разницей что указывает //вес// величины. Например если контейнер содержит 2 потомка ''width = 1*'', а второго ''width = 3*'', то на этапе вычисления первого потомку достанется 1/4 родительской ширины, а второму 3/4 (всё остальное).

И также существуют два специальных значения:

  * **None** (designated as //none//) - аналог null, введёно чтобы объект Gauge существовал всегда. Так что при вычислении размеров любые аттрибуты равные none - игнорируются.
  * **Auto** (designated as //auto//) - специальное значение которое говорит что конкретное значение, вычисляется в зависимости от контекста, например для //width// или //height// эти значения опредеяются по размерам потомков и алгоритма layout.

Все аттрибуты которые определяют размер выражены через Gauge, для самых основных аттрбутов (//width//, //height//, //margin//, //padding// etc) в узле есть типизированные методы доступа через отдельные свойства.

=== Layout Phases ===
В простейшем случае механизм выравнивания представляет из себя простой обход дерева элементов и каждый родительский элемент выставляет в определённых для него размером (его родителем) своих непосредственных потомков.

Небольшое услождение появляется когда родительский элемент не знает какие размеры он должен принять (ему их никто не сказал) по этому перед тем как произвести расположение своих потомков, он должен произвести из измерение, с целью определения размера которое он должен занять, итого механизм состоит из 2х фаз:
  - **Measurment** - //не обязательная// фаза, нужна только если у узлу никто не передал размеры которые он должен занять.
  - **Arrangment** - расположение потомков согласно своей стратегии (рекурсивно)

Рассмотрим следующий пример:
<code xml>
<root>
	<ruler width="100px" height="20px" />
	<container>
		<button height="64px" width="128px" />
		<button height="64px" width="128px" />
	</container>
	<ruler width="100px" height="20px" />
</root>
</code>

{{ https://dl.dropboxusercontent.com/u/31235920/TalonTeaser/update.gif?nolink }}

==== Custom Talon ====
In this part expands  how to write custom talon behviour
=== Custom Element ===
<code as3>
public class CustomElement extens Sprite implemens ITalonElement
{
	private var _node:Node;

	public function CustomElement()
	{
		_node = new Node();
		_node.addEventListener(Event.CHANGE, onNodeAttributeChange);
		_node.addEventListener(Event.RESIZE, onNodeResize);
	}	
	
	private function onNodeAttributeChange(e:Event):void
	{
		var attributeName:String = String(e.data);
		var attributeValue:String = _node.getAttribute(attributeName);
		// Make all element changes based on this attribute value
		// ...
	}

	private function onNodeResize(e:Event):void
	{
		// Position/resize element within node#bounds rectangle
		x = node.bounds.x;
		y = node.bounds.y;			
		//...
	}

	// Single property from ITalonElement interface
	public function get node():Node
	{
		return _node;
	}
}
</code>
Simple implement this interface in your own class.

=== Custom Layout ===
<code as3>
public class CustomLayout extends Layout
{
	public function measureAutoWidth(node:Node, width:Number, height:Number):Number
	{
		// Calculate and return node width like it is 'auto'
	}

	public function measureAutoHeight(node:Node, width:Number, height:Number):Number
	{
		// Calculate and return node height like it is 'auto'
	}

	public function arrange(node:Node, width:Number, height:Number):void
	{
		// Arrange node children within bounds (0; 0; width; height)
		// and invoke theirs commit() method after all.
	}
}
</code>
Simple inherit this class and add it in static layout registry:

<code as3>
Layout.registerLayoutAlias("custom", CustomLayout
</code>

===== Appendix 1: CSS Dialect (Working Draft) =====

