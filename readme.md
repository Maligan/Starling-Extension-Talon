# Talon (Working Draft)
Talon — Responsive UI engine for <a href="http://gamua.com/starling/">Starling</a>.

## Features
Talon engine allows you:
- Use [XML syntax](#tml) for declarative markup interface
- Apply [CSS dialect](#css) for easy skinning and styling
- Build interface with [responsive layouts](#layouts)
- View interface outside your app with [talon browser](#browser)

## Basics
Прежде чем перейти ко всех особенностями и модулям небольшие фундаментальные правила на которых основан талон и которые являются его ядром и единственной обязательной частью.

Базовыми понятиями являются - узел и атрибут.
Узел - набор атрибутов + прикрепленный словарь ресурсов + прикрепления страница стилей + прямоугольк-размер
Атрибут - именованное значение, значение атрибута — всегда строка *без единого исключения*
Все атрибуты равноправны *без исключений*, то что можно делать с одним аттрибутом можно делать с любым другим.

Значение атрибута вычисляется по приоритету: значение по-умолчанию, значение заданное из стиля, значение явно заданное узлу.
Некоторые из атрибутов могут быть "унаследованы" в таком случае их фактическое значение это ключевое слово *inherit*, но для вычислений берётся значение того же атрибута родительского узла.

![Как множатся стандарты](docs/img/Dialog-Expanded.png)

Любой интерфейс представляет из себя - дерево из узлов.
Словари ресурсов и стили распространяются по иерархии: от родителей ко всем детям. Если у детей есть собственные стили то они смешиваются с родительским с безоговорочным приоритетом собственных стилей.

Собственно вот и все правила на которых основан движок, всё остальное - построено на этих правилах или же является просто удобным дополнением.

## TML (Template Markup Language)
> «Списывание с одного источника — плагиат, с двух — компиляция, с трех и более — диссертация»

XInclude, XSLT, TAL (и его наследники Genshi, Kid)

- XSLT — Это очень мощный инструмент общего пользования, хоть его сложность в разы меньше его мощности всё равно для моих целей он казался ядерной боеголовкой для охоты на уток. Тем не менее основной принцип что xslt - это набор шаблонов и трансформаций связаных с ними я позаимсвовал, но сильно упростив систему трансформации.

- XInclude — был удивлён когда нашёл этот механизм, очень маленький и симпотичный, но как бы это забавно небыло его функционала явно мне не достаточно было - едиственное что он позваляет - включать один xml документ (или его часть) в другой.

- TAL — это было почти точное поподание по функицоналу того что мне нужно было, хотя в ?них? есть немного императивной логики, но они попали в точку - в них ввыводится 4 основных типа изменения дерева - замена контента, замена узла, замена аттрибутов и добавление узлов. Но мне как-то оказался не мила идея использования аттрибутов для шиблонизации, мне как-то больше по душе были синтаксис основаный на тегах как в XSLT и XInclude.

### Базовые принципы
- *Шаблон* — именованное дерево элементов.
- *Элемент* — бывают 2х типов:
	1. Терминальный
	2. Не терминальный — это шаблон и быть может набор перезаписей.
- *Перезапись* — 

Немного увёкшись формальными граматиками мне понравилась та аналогия которую мне удалось провестио
Шаблон - это дерево элементов и возможно набор трансофрмаций над ним
Дерево - состоиз из одельных узлов-элементов
Каждый элемент может быть двух типов - терминалом и не терминалом.
Терминал это примитивный узел который является базовым кирпичиком. (на примере html - это те самые div и span)
Не терминал - это поддерево - шаблон т.е. поддерево и набор трансформаций над ним
Таким образом при сборке интерфейса - это всегда набор только терминальных узлов, но на этапе макета? его можно сильно сжать изпользую шаблоны

### Трансофрмации

### Ключевые теги
Tag-Keywords:
- `rewrite` - replace any subtree on exists tree pattern (consist from 1 child (root) if mode==replace, any count of child if mode==content, empty if mode==attributes)
	+ `ref` - mandatory subtree root id
	+ `mode` - attributes / replace / content
- `template` - create tree pattern (consists from only 1 child (root))
	+ `id` - mandatory
	+ `type` - linkage tag name
- `library` - use as container for define, style и другие
- `style` - use to add css in library (without create addition .css file)


### Алгоритм обхода дерева
- replace
- content
- attributes

### Итог
Немного не получилось

![Как множатся стандарты](http://xkcd.ru/i/927_v4.png)

## Layouts
За размер и положение любого узла отвечает **только** его непосредственный родитель (без исключений)

- Недопустимо использовать относительные размеры (*%*, *\**) в потомках если в родителе опущен целевой аттрибут (в значении auto)
    - Вариант с проброссом целевого атрибута от непосредственного родителя вверх по иерархии был проверен и на мой взгляд интуитивно не понятен (пример для цепочки px -> auto + padding -> auto)
	- Результат: на этапе оределение любые % измерения эквивалентны 0?

Единицы измерения:
- **auto** - Означает что значение величины должно определятся из контекста (для width/height это подразумевает определение размеров по потомкам и шаблону)
- **px** - Обычный пиксель
- **pt** - Типографский пункт (равет 1/72 дюйма). Является машинно-независимой единицей.
- **em** - Масштабируемая едиица измерения, 1em = *fontSize* текущего узла.
- **%** - Относительная единица. В процентах от *целевой велечины* (которая определяется по контексту)
- **\*** - Относительная единица. *Вес* относительно других дочерних элементов, c целевой величиной определяемой по контексту.

#### absolute
Used children attributes:	
- anchor
- x, y
- width, height
- minWidth, minHeight
- maxWidth, maxHeight
- margin
- pivotX, pivotY
- (?) scaleX, scaleY
Used self attributes:
- originX, originY
- padding

#### flow
Used self attributes:
- orientation
- gap
- interline
- halign
- valign
- wrap

Used children attributes:
- width, height
- minWidth, minHeight
- maxWidth, maxHeight
- break
- (?) ihalign 
- (?) ivalign

#### grid

## CSS
В отличии от стандарта CSS разработанного W4C стили содержатся не в отдельном свойстве узла *styles*, а выставляют значение аттрбутов *по-умолчанию*.
То есть если есть такая структура:

**Верно**
```xml
<node backgroundColor="red" />
```

**Неверно**
```xml
<node style="backgroundColor: red" />
```

С помощью CSS может быть установлен *любой* аттрибут узла (можно даже придумывать свои), кроме:
- id
- type
- class
- state (aka всевдо класс)

Значение любого атрибута - только строковая переменная.
Сделано это усугубо для упрощения понимания того факта что одни и теже атрибуты задатся как из таблицы стилей так и из документа разметки.

#### CSS Dialect
В названиях аттрбутов используется только *малаяВерблюжьяНотация*, без чёрточек как в W3C/Flex диалектах.
Следующий список аттрибутов используется в движке:

@ Подробный и полный список поддерживаемых свойств.
