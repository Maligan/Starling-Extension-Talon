# TML - Template Markup Language
`HTML, MXML, XAML, XUL, FXML` - существует большое количество языков дл дкларативной разметки интерфейсов, у каждого из них свои плюшки, и примочки. Воспользовавшись большинством из этого списка у меня появились любымые части. После того как MXML умер (ссылку) мне очень хотелось получить что-то подобное, но очень легковестное для работы над небольшими игрушками. Набравшись терпения я решил воплотить их в жинь. Очень не хотелось чтобы получилось так как это должно было произойти:

![Как множатся стандарты](http://xkcd.ru/i/927_v4.png)

По этому я сразу определился с областью применения TML - это небольшие интерфейсы не содержащих сложных контролов типа Grid/Tree/ComboBox и прочих.

## Компиляция
Когда я пмсал свои диплом мой руководитель не однократно говорил мне — «Списывание с одного источника — плагиат, с двух — компиляция, с трех и более — диссертация». Первым делом я решил выделить что мне нравиться в других языках, а что нет.

### HTML
Завлекает меня своей динамичной типизаций в сравнении с остальными языками, поддержкой CSS и отсутсвием сложным компонент - любой элемент описывается при помощи парку тройки простых правил - Box Model, стили, правила отображения и наборам простых элементов - div, span, img

Из минусов - отсутствие возможности шаблонизации "из коробки" (для этих целей используется XSLT, но о нём позже). По этой причине сложные элементы довольно трудно описывать и это выливается в нагрузку на css (before, after, аттрибут content) которые на мой порят css.
И конечно же лейауты, здесь я много говорить не буду - просто хочу вспомнить чего стоило вертикальное выравнивание блока по вертикали до HTML5/CSS3

### MXML, XAML, FXML
В целом они очень похоже, на мой вкус мне больше всех понравился XAML по этому приемущества и минусы я буду описывать по нему.

То чего не хватало мне в html-е - шаблонизации, здесь реализцются через компоненты - есть возможность создать любой компонет состоящего из сложной иерархии, а потом использовать его многократно одним вызовом.
Layout-ы конечно тоже мне здесь доставили больое удовольствие - (тут я явно на стороне XAML, т.к. для меня StackLayout намного ближе чем пара VGroup, HGroup тем что он работает интуитивно понятно для меня)
Что уж там говорит о привязках им просто цены нет.
И ещё из интересного могу назвать  словари ресурсов, в MXML они имеют ещё примитивнуцю форму но вот в двух других (точно?) они приобретают иерархическую форму и очень элегантно распределены по дереву элементов.

У каждого из этих языков есть оборотная сторона - большая сложность, слишком большой объём базоых понятий и размер библиотеки с которой нужно считатся. Этот огромный объём знаний пуает когда хочешь воспользоватся ими для маленьких и акуратненьких решений.
Можно придератся к мелочам типа расширения разметки, встроеный код mxml, свойства зависимостей и прочее, но это всё одно и тоже проявление - колосальная сложность фреймворков.

### XSLT, XInclude, TAL, Genshi, Kid
Формально это не языки для разметки интерфейсов, но эти технологии/спецификации реализуют шаблонизацию - то что я очень хотел видеть в своей реализации. В двух словах о том что я них думаю:

* XSLT - Это очень мощный инструмент общего пользования, хоть его сложность в разы меньше его мощности всё равно для моих целей он казался ядерной боеголовкой для охоты на уток. Тем не менее основной принцип что xslt - это набор шаблонов и трансформаций связаных с ними я позаимсвовал, но сильно упростив систему трансформации.
* XInclude - был удивлён когда нашёл этот механизм, очень маленький и симпотичный, но как бы это забавно небыло его функционала явно мне не достаточно было - едиственное что он позваляет - включать один xml документ (или его часть) в другой.
* TAL (как и наследники Genshi, Kid) - это было почти точное поподание по функицоналу того что мне нужно было, хотя в ?них? есть немного императивной логики, но они попали в точку - в них ввыводится 4 основных типа изменения дерева - замена контента, замена узла, замена аттрибутов и добавление узлов. Но мне как-то оказался не мила идея использования аттрибутов для шиблонизации, мне как-то больше по душе были синтаксис основаный на тегах как в XSLT и XInclude.

## Базовые принципы
	* *Шаблон* — именованное дерево элементов.
	* *Элемент* — ___ — бывают 2х типов:
		1. Терминальный
		2. Не терминальный — это шаблон и быть может набор перезаписей.
	* *Перезапись* — 

Немного увёкшись формальными граматиками мне понравилась та аналогия которую мне удалось провестио
Шаблон - это дерево элементов и возможно набор трансофрмаций над ним
Дерево - состоиз из одельных узлов-элементов
Каждый элемент может быть двух типов - терминалом и не терминалом.
Терминал это примитивный узел который является базовым кирпичиком. (на примере html - это те самые div и span)
Не терминал - это поддерево - шаблон т.е. поддерево и набор трансформаций над ним
Таким образом при сборке интерфейса - это всегда набор только терминальных узлов, но на этапе макета? его можно сильно сжать изпользую шаблоны

### Трансофрмации

### Ключевые теги
Tag-Keywords:
 - `rewrite` - replace any subtree on exists tree pattern (consist from 1 child (root) if mode==replace, any count of child if mode==content, empty if mode==attributes)
	+ `ref` - mandatory subtree root id
	+ `mode` - attributes | replace | content
 - `template` - create tree pattern (consists from only 1 child (root))
	+ `id` - mandatory
	+ `type` - linkage tag name
 - `library` - use as container for <define>, <style> и другие
 - `style` - use to add css in library (without create addition .css file)

### Алгоритм обхода дерева
 - replace
 - content
 - attributes
